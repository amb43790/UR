%right OR
%right AND
%left NEGATIVE

%%

expr: condition                   { $_[1] }
    | expr AND expr               { [ @{$_[1]}, @{$_[3]} ] }
    | expr OR expr                { [ [$_[1]], [$_[3]] ] }
    | LEFT_PAREN expr RIGHT_PAREN { $_[2] }
    ;

condition: property operator value                 { [ "$_[1] $_[2]" => $_[3] ] }
         | property like_operator LIKE_PATTERN     { [ "$_[1] $_[2]" => $_[3] ] }
         | property in_operator in_value           { [ "$_[1] $_[2]" => $_[3] ] }
         | property between_operator between_value { [ "$_[1] $_[2]" => $_[3] ] }
         ;

property:   IDENTIFIER { $_[1] }
        ;

operator: an_operator           { $_[1] }
        | negation an_operator  { "$_[1] $_[2]" }
        ;

negation: NOT { 'not' }
        ;

an_operator: equality  { $_[1] }
           | OPERATORS { $_[1] }
        ;

equality: EQUAL_SIGN { '=' }
        | DOUBLEEQUAL_SIGN { '=' }
        ;

like_operator: LIKE { 'like' }
             | negation LIKE { "$_[1] like" }
             ;

in_operator: IN { 'in' }
           | negation IN { "$_[1] in" }
           ;

in_value: set  { $_[1] }
        | value IN_DIVIVER in_value { [ $_[1], @{$_[3]} ] }
        ; 

set: LEFT_BRACKET set_body RIGHT_BRACKET { $_[2] }
   ;

set_body: value COMMA set_body { [ $_[1], @{$_[3]} ] }
        | value { [ $_[1] ] }
        ;

between_operator: BETWEEN { 'between' }
                | negation BETWEEN { "$_[1] between" }
                ;

between_value: value BETWEEN_RANGE value { [ $_[1], $_[3] ] }
             ;
   
keyword: AND { $_[1] }
       | OR  { $_[1] }
       ;

value: IDENTIFIER { $_[1] }
     | number { $_[1] }
     | WORD   { $_[1] }
     | DOUBLEQUOTE_STRING { ($_[1] =~ m/^"(.*?)"$/)[0]; }
     | SINGLEQUOTE_STRING { ($_[1] =~ m/^'(.*?)'$/)[0]; }
     | keyword { $_[1] }
     ;

number: INTEGER { $_[1] }
      | REAL    { $_[1] }
      | NEGATIVE INTEGER { -$_[2] } # to reject --5
      | NEGATIVE REAL { -$_[2] }
      ; 

%%

package UR::BoolExpr::BxParser;

use strict;
use warnings;

sub _error {
    my @expect = $_[0]->YYExpect;
    my $tok = $_[0]->YYData->{INPUT};
    my $err = "Syntax error near '$tok'";
    my $rem = $_[0]->YYData->{REMAINING};
    $err .= ", remaining text: '$rem'" if $rem;
    $err .= "\nExpected one of: " . join(", ", @expect) . "\n";
    Carp::croak($err);
}

my @tokens = (
    AND => qr{and|,},
    OR => qr{or},
    IDENTIFIER => qr{[a-zA-Z_][a-zA-Z0-9_.]*},
    NEGATIVE => qr{-},
    INTEGER => qr{\d+},
    REAL => qr{\d*\.\d+|\d+\.\d*},
    WORD => qr{\w+},
    DOUBLEQUOTE_STRING => qr{"(\\.|[^"])+"},
    SINGLEQUOTE_STRING => qr{'(\\.|[^'])+'},
    LEFT_PAREN => qr{\(},
    RIGHT_PAREN => qr{\)},
    LEFT_BRACKET => qr{\[},
    RIGHT_BRACKET => qr{\]},
    COMMA => qr{,},
    NOT_WORD => qr{not},
    NOT_BANG => qr{!},
    EQUAL_SIGN => qr{=},
    DOUBLEEQUAL_SIGN => qr{=>},
    OPERATORS => qr{<|>|<=|>=},
    BETWEEN => qr{between|:},
    IN => qr{in|:|=},
    LIKE => qr{like|~},
    LIKE_PATTERN => qr{[\w%_]+},
    IN_DIVIDER => qr{\/},
    BETWEEN_RANGE => qr{-},
);

sub parse {
    my $string = shift;

print "\nStarting parse for string $string\n";
    my $parser = BxParser->new();

    my $get_next_token = sub {
        if (length($string) == 0) {
print "String is empty, we're done!\n";
            return (undef, '');  
       }

        my $longest = 0;
        my $longest_token = '';
        my $longest_match = '';

        for(my $i = 0; $i < @tokens; $i += 2) {
            my($tok, $regex) = @tokens[$i, $i+1];
print "Trying token $tok... ";

            if ($string =~ m/^(\s*($regex)\s*)/) {
print "Matched >>$1<<";
                my $match_len = length($1);
                if ($match_len > $longest) {
print "\n  ** It's now the longest";
                    $longest = $match_len;
                    $longest_token = $tok;
                    $longest_match = $2;
                }
            }
print "\n";
        }

        $string = substr($string, $longest);
print "Consuming up to char pos $longest chars, string is now >>$string<<\n";
        $parser->YYData->{REMAINING} = $string;
        if ($longest) {
            $parser->YYData->{INPUT} = $longest_token;
print "Returning token $longest_token, match $longest_match\n";;
            return ($longest_token, $longest_match);
        }
print "Didn't match anything, done!\n";
        return (undef, '');  # Didn't match anything
    };

    return $parser->YYParse(
               yylex => $get_next_token,
               yyerror => \&_error,
               yydebug => 0,
           );
}

